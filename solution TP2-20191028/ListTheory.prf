(ListTheory
 (simple2 0
  (yes "another one" 3685066391
   ("" (skosimp)
    (("" (rewrite "length_cons")
      (("" (rewrite "length_cons")
        (("" (rewrite "length_nil") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((length_cons formula-decl nil ListTheory nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[List -> boolean]" List_adt nil)
    (cons adt-constructor-decl "[[T, List] -> (cons?)]" List_adt nil)
    (empty? adt-recognizer-decl "[List -> boolean]" List_adt nil)
    (nil adt-constructor-decl "(empty?)" List_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_nil formula-decl nil ListTheory nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers
     nil))
   shostak)
  (simple2-1 nil 3684481785
   ("" (skosimp)
    (("" (rewrite "length_cons")
      (("" (rewrite "length_cons")
        (("" (rewrite "length_nil") (("" (ground) nil nil)) nil)) nil))
      nil))
    nil)
   ((length_cons formula-decl nil ListTheory nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[List -> boolean]" List_adt nil)
    (cons adt-constructor-decl "[[T, List] -> (cons?)]" List_adt nil)
    (empty? adt-recognizer-decl "[List -> boolean]" List_adt nil)
    (nil adt-constructor-decl "(empty?)" List_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_nil formula-decl nil ListTheory nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers
     nil))
   shostak))
 (th1 0
  (th1-1 nil 3598861726
   ("" (skosimp)
    ((""
      (auto-rewrite-theory-with-importings "ListTheory" :always? true
       :importchain? true)
      (("" (do-rewrite) nil nil)) nil))
    nil)
   ((List_cons_extensionality formula-decl nil List_adt nil)
    (putlast_cons formula-decl nil ListTheory nil)
    (reverse_cons formula-decl nil ListTheory nil)
    (putlast_nil formula-decl nil ListTheory nil)
    (reverse_nil formula-decl nil ListTheory nil))
   shostak))
 (th6 0
  (th6-1 nil 3598865030
   (""
    (auto-rewrite-theory-with-importings "ListTheory" :always? true
     :importchain? true)
    (("" (induct "l")
      (("1" (skosimp) (("1" (do-rewrite) nil nil)) nil)
       ("2" (skosimp)
        (("2" (skosimp)
          (("2" (inst -1 "x!1") (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[List[T] -> nat]" ListTheory nil)
    (putlast const-decl "[List[T], T -> List[T]]" ListTheory nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List_induction formula-decl nil List_adt nil)
    (length_cons formula-decl nil ListTheory nil)
    (length_nil formula-decl nil ListTheory nil)
    (putlast_nil formula-decl nil ListTheory nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (putlast_cons formula-decl nil ListTheory nil))
   shostak))
 (th4 0
  (th4-2 "plus simple" 3684373099
   (""
    (auto-rewrite-theory-with-importings "ListTheory" :always? true
     :importchain? true)
    (("" (induct "l")
      (("1" (do-rewrite) nil nil)
       ("2" (skosimp)
        (("2" (rewrite "reverse_cons")
          (("2" (rewrite "th6") (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[List[T] -> nat]" ListTheory nil)
    (reverse const-decl "[List[T] -> List[T]]" ListTheory nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List_induction formula-decl nil List_adt nil)
    (reverse_nil formula-decl nil ListTheory nil)
    (length_nil formula-decl nil ListTheory nil)
    (reverse_cons formula-decl nil ListTheory nil)
    (length_cons formula-decl nil ListTheory nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (th6 formula-decl nil ListTheory nil))
   shostak)
  (th4-1 nil 3598864701
   (""
    (auto-rewrite-theory-with-importings "ListTheory" :always? true
     :importchain? true)
    (("" (induct "l")
      (("1" (do-rewrite) nil nil)
       ("2" (skosimp)
        (("2" (rewrite "reverse_cons" 1)
          (("2" (rewrite "th6" +) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[List[T] -> nat]" ListTheory nil)
    (reverse const-decl "[List[T] -> List[T]]" ListTheory nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List_induction formula-decl nil List_adt nil)
    (reverse_nil formula-decl nil ListTheory nil)
    (length_nil formula-decl nil ListTheory nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reverse_cons formula-decl nil ListTheory nil)
    (th6 formula-decl nil ListTheory nil)
    (length_cons formula-decl nil ListTheory nil))
   shostak))
 (th5 0
  (th5-2 "avec do-rewrite" 3684373364
   (""
    (auto-rewrite-theory-with-importings "ListTheory" :always? true
     :importchain? true)
    (("" (induct "l")
      (("1" (do-rewrite) (("1" (skosimp) nil nil)) nil)
       ("2" (skosimp)
        (("2" (skosimp)
          (("2" (do-rewrite) (("2" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[List[T] -> nat]" ListTheory nil)
    (append const-decl "[List[T], List[T] -> List[T]]" ListTheory nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List_induction formula-decl nil List_adt nil)
    (append_nil formula-decl nil ListTheory nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_nil formula-decl nil ListTheory nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_cons formula-decl nil ListTheory nil)
    (append_cons formula-decl nil ListTheory nil))
   shostak)
  (th5-1 nil 3598865393
   ("" (induct "l")
    (("1" (skosimp)
      (("1" (rewrite "append_nil" 1)
        (("1" (grind) (("1" (rewrite "length_nil" 1) nil nil)) nil))
        nil))
      nil)
     ("2" (skosimp)
      (("2" (skosimp)
        (("2" (rewrite "append_cons" 1)
          (("2" (inst?)
            (("2" (do-rewrite)
              (("2"
                (auto-rewrite-theory-with-importings "ListTheory"
                 :always? true :importchain? true)
                (("2" (do-rewrite) (("2" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length const-decl "[List[T] -> nat]" ListTheory nil)
    (append const-decl "[List[T], List[T] -> List[T]]" ListTheory nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List_induction formula-decl nil List_adt nil)
    (length_nil formula-decl nil ListTheory nil)
    (append_nil formula-decl nil ListTheory nil)
    (length_cons formula-decl nil ListTheory nil)
    (append_cons formula-decl nil ListTheory nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil))
   shostak))
 (thaux 0
  (thaux-1 nil 3598866644
   (""
    (auto-rewrite-theory-with-importings "ListTheory" :always? true
     :importchain? true)
    (("" (induct "l")
      (("1" (skosimp) (("1" (do-rewrite) nil nil)) nil)
       ("2" (skosimp)
        (("2" (skosimp)
          (("2" (rewrite "putlast_cons" 1)
            (("2" (rewrite "reverse_cons" 1)
              (("2" (inst?)
                (("2" (replace -1 (1))
                  (("2" (rewrite "putlast_cons" 1)
                    (("2" (rewrite "reverse_cons" 1) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (reverse const-decl "[List[T] -> List[T]]" ListTheory nil)
    (putlast const-decl "[List[T], T -> List[T]]" ListTheory nil)
    (cons? adt-recognizer-decl "[List -> boolean]" List_adt nil)
    (cons adt-constructor-decl "[[T, List] -> (cons?)]" List_adt nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List_induction formula-decl nil List_adt nil)
    (List_cons_extensionality formula-decl nil List_adt nil)
    (reverse_cons formula-decl nil ListTheory nil)
    (reverse_nil formula-decl nil ListTheory nil)
    (putlast_nil formula-decl nil ListTheory nil)
    (putlast_cons formula-decl nil ListTheory nil))
   shostak))
 (th3 0
  (th3-1 nil 3598863630
   (""
    (auto-rewrite-theory-with-importings "ListTheory" :always? true
     :importchain? true)
    (("" (induct "l")
      (("1" (do-rewrite) nil nil)
       ("2" (skosimp)
        (("2" (rewrite "reverse_cons" 1)
          (("2" (rewrite "thaux" 1)
            (("2" (replace -1 (1)) (("2" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((List type-decl nil List_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (reverse const-decl "[List[T] -> List[T]]" ListTheory nil)
    (T formal-nonempty-type-decl nil ListTheory nil)
    (List_induction formula-decl nil List_adt nil)
    (reverse_nil formula-decl nil ListTheory nil)
    (List_nil_extensionality formula-decl nil List_adt nil)
    (reverse_cons formula-decl nil ListTheory nil)
    (thaux formula-decl nil ListTheory nil))
   shostak)))

